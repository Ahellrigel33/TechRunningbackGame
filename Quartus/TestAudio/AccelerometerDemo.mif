-- Altera Memory Initialization File (MIF)

DEPTH = 1048576;
WIDTH = 16;

ADDRESS_RADIX = HEX;
DATA_RADIX = HEX;

CONTENT
  BEGIN
    00000 : 8009; -- CALL   SetupI2C
    00001 : 801f; -- CALL   ReadX
    00002 : 1146; -- STORE  L2A
    00003 : 8029; -- CALL   ReadY
    00004 : 1147; -- STORE  L2B
    00005 : 811c; -- CALL   L2Estimate
    00006 : 6014; -- SHIFT  -4
    00007 : 9801; -- OUT    LEDs
    00008 : 2801; -- JUMP   Start    ; Repeat
    00009 : 0960; -- LOAD   AccCfg      ; load the number of commands
    0000a : 101e; -- STORE  CmdCnt
    0000b : b960; -- LOADI  AccCfg      ; Load list address
    0000c : 6801; -- ADDI   1           ; Increment to first command
    0000d : 101d; -- STORE  CmdPtr
    0000e : 803d; -- CALL   BlockI2C    ; wait for idle
    0000f : 095c; -- LOAD   I2CWCmd     ; load write command
    00010 : 9890; -- OUT    I2C_CMD     ; to I2C_CMD register
    00011 : 701d; -- ILOAD  CmdPtr      ; load current command
    00012 : 9891; -- OUT    I2C_DATA    ; to I2C_DATA register
    00013 : 9892; -- OUT    I2C_RDY     ; start the communication
    00014 : 803d; -- CALL   BlockI2C    ; wait for it to finish
    00015 : 081d; -- LOAD   CmdPtr
    00016 : 6801; -- ADDI   1           ; Increment to next command
    00017 : 101d; -- STORE  CmdPtr
    00018 : 081e; -- LOAD   CmdCnt
    00019 : 6fff; -- ADDI   -1          ; Check if finished
    0001a : 101e; -- STORE  CmdCnt
    0001b : 380e; -- JPOS   I2CCmdLoop
    0001c : 8800; -- RETURN
    0001d : 0000; -- CmdPtr: DW 0
    0001e : 0000; -- CmdCnt: DW 0
    0001f : 803d; -- CALL   BlockI2C    ; ensure bus is idle
    00020 : 095d; -- LOAD   I2CRCmd     ; load read command
    00021 : 9890; -- OUT    I2C_CMD     ; send read command to I2C_CMD register
    00022 : 095e; -- LOAD   AccXAddr    ; load ADXL345 register address for X acceleration
    00023 : 9891; -- OUT    I2C_DATA    ; send to I2C_DATA register
    00024 : 9892; -- OUT    I2C_RDY     ; start the communication
    00025 : 803d; -- CALL   BlockI2C    ; wait for it to finish
    00026 : 9091; -- IN     I2C_data    ; put the data in AC
    00027 : 8033; -- CALL   SwapBytes   ; bytes are returned in wrong order; swap them
    00028 : 8800; -- RETURN
    00029 : 803d; -- CALL   BlockI2C    ; ensure bus is idle
    0002a : 095d; -- LOAD   I2CRCmd     ; load read command
    0002b : 9890; -- OUT    I2C_CMD     ; send read command to I2C_CMD register
    0002c : 095f; -- LOAD   AccYAddr    ; load ADXL345 register address for X acceleration
    0002d : 9891; -- OUT    I2C_DATA    ; send to I2C_DATA register
    0002e : 9892; -- OUT    I2C_RDY     ; start the communication
    0002f : 803d; -- CALL   BlockI2C    ; wait for it to finish
    00030 : 9091; -- IN     I2C_data    ; put the data in AC
    00031 : 8033; -- CALL   SwapBytes   ; bytes are returned in wrong order; swap them
    00032 : 8800; -- RETURN
    00033 : 103b; -- STORE  SBT1
    00034 : 6008; -- SHIFT  8
    00035 : 103c; -- STORE  SBT2
    00036 : 083b; -- LOAD   SBT1
    00037 : 6018; -- SHIFT  -8
    00038 : 495a; -- AND    LoByte
    00039 : 503c; -- OR     SBT2
    0003a : 8800; -- RETURN
    0003b : 0000; -- SBT1: DW 0
    0003c : 0000; -- SBT2: DW 0
    0003d : 094e; -- LOAD   Zero
    0003e : 114b; -- STORE  Temp        ; Used to check for timeout
    0003f : 094b; -- LOAD   Temp
    00040 : 6801; -- ADDI   1           ; this will result in ~0.1s timeout
    00041 : 114b; -- STORE  Temp
    00042 : 4046; -- JZERO  I2CError    ; Timeout occurred; error
    00043 : 9092; -- IN     I2C_RDY     ; Read busy signal
    00044 : 383f; -- JPOS   BI2CL       ; If not 0, try again
    00045 : 8800; -- RETURN             ; Else return
    00046 : 094e; -- LOAD   Zero
    00047 : 692c; -- ADDI   &H12C       ; "I2C"
    00048 : 9804; -- OUT    Hex0        ; display error message
    00049 : 2846; -- JUMP   I2CError
    0004a : 1050; -- STORE  DelayTime   ; Save the desired delay
    0004b : 9802; -- OUT    Timer       ; Reset the timer
    0004c : 9002; -- IN     Timer       ; Get the current timer value
    0004d : 2050; -- SUB    DelayTime
    0004e : 304c; -- JNEG   WaitingLoop ; Repeat until timer = delay value
    0004f : 8800; -- RETURN
    00050 : 0000; -- DelayTime: DW 0
    00051 : 3854; -- JPOS   Abs_r
    00052 : 594f; -- XOR    NegOne       ; Flip all bits
    00053 : 6801; -- ADDI   1            ; Add one (i.e. negate number)
    00054 : 8800; -- RETURN
    00055 : 08b5; -- LOAD   AtanY
    00056 : 8051; -- CALL   Abs          ; abs(y)
    00057 : 10b7; -- STORE  AtanT
    00058 : 08b4; -- LOAD   AtanX        ; abs(x)
    00059 : 8051; -- CALL   Abs
    0005a : 20b7; -- SUB    AtanT        ; abs(x) - abs(y)
    0005b : 3066; -- JNEG   A2_sw        ; if abs(y) > abs(x), switch arguments.
    0005c : 08b4; -- LOAD   AtanX        ; Octants 1, 4, 5, 8
    0005d : 3063; -- JNEG   A2_R3
    0005e : 8075; -- CALL   A2_calc      ; Octants 1, 8
    0005f : 3061; -- JNEG   A2_R1n
    00060 : 8800; -- RETURN              ; Return raw value if in octant 1
    00061 : 6968; -- ADDI   360          ; Add 360 if we are in octant 8
    00062 : 8800; -- RETURN
    00063 : 8075; -- CALL   A2_calc      ; Octants 4, 5
    00064 : 68b4; -- ADDI   180          ; theta' = theta + 180
    00065 : 8800; -- RETURN
    00066 : 08b5; -- LOAD   AtanY        ; Swap input arguments
    00067 : 10b7; -- STORE  AtanT
    00068 : 08b4; -- LOAD   AtanX
    00069 : 10b5; -- STORE  AtanY
    0006a : 08b7; -- LOAD   AtanT
    0006b : 10b4; -- STORE  AtanX
    0006c : 3871; -- JPOS   A2_R2        ; If Y positive, octants 2,3
    0006d : 8075; -- CALL   A2_calc      ; else octants 6, 7
    0006e : 8052; -- CALL   Neg          ; Negatge the number
    0006f : 690e; -- ADDI   270          ; theta' = 270 - theta
    00070 : 8800; -- RETURN
    00071 : 8075; -- CALL   A2_calc      ; Octants 2, 3
    00072 : 8052; -- CALL   Neg          ; negate the angle
    00073 : 685a; -- ADDI   90           ; theta' = 90 - theta
    00074 : 8800; -- RETURN
    00075 : 08b5; -- LOAD   AtanY
    00076 : 1114; -- STORE  d16sN        ; Y in numerator
    00077 : 08b4; -- LOAD   AtanX
    00078 : 1115; -- STORE  d16sD        ; X in denominator
    00079 : 80a1; -- CALL   A2_div       ; divide
    0007a : 091a; -- LOAD   dres16sQ     ; get the quotient (remainder ignored)
    0007b : 10b6; -- STORE  AtanRatio
    0007c : 10dd; -- STORE  m16sA
    0007d : 10de; -- STORE  m16sB
    0007e : 8098; -- CALL   A2_mult      ; X^2
    0007f : 10dd; -- STORE  m16sA
    00080 : 08b8; -- LOAD   A2c
    00081 : 10de; -- STORE  m16sB
    00082 : 8098; -- CALL   A2_mult
    00083 : 6900; -- ADDI   256          ; 256/256+0.28125X^2
    00084 : 1115; -- STORE  d16sD
    00085 : 08b6; -- LOAD   AtanRatio
    00086 : 1114; -- STORE  d16sN        ; Ratio in numerator
    00087 : 80a1; -- CALL   A2_div       ; divide
    00088 : 091a; -- LOAD   dres16sQ     ; get the quotient (remainder ignored)
    00089 : 10dd; -- STORE  m16sA        ; <= result in radians
    0008a : 08b9; -- LOAD   A2cd         ; degree conversion factor
    0008b : 10de; -- STORE  m16sB
    0008c : 8098; -- CALL   A2_mult      ; convert to degrees
    0008d : 10b7; -- STORE  AtanT
    0008e : 6017; -- SHIFT  -7           ; check 7th bit
    0008f : 4950; -- AND    One
    00090 : 4095; -- JZERO  A2_rdwn      ; round down
    00091 : 08b7; -- LOAD   AtanT
    00092 : 6018; -- SHIFT  -8
    00093 : 6801; -- ADDI   1            ; round up
    00094 : 8800; -- RETURN
    00095 : 08b7; -- LOAD   AtanT
    00096 : 6018; -- SHIFT  -8           ; round down
    00097 : 8800; -- RETURN
    00098 : 80ba; -- CALL   Mult16s
    00099 : 08e2; -- LOAD   mres16sH
    0009a : 6008; -- SHIFT  8            ; move high word of result up 8 bits
    0009b : 10e2; -- STORE  mres16sH
    0009c : 08e1; -- LOAD   mres16sL
    0009d : 6018; -- SHIFT  -8           ; move low word of result down 8 bits
    0009e : 495a; -- AND    LoByte
    0009f : 50e2; -- OR     mres16sH     ; combine high and low words of result
    000a0 : 8800; -- RETURN
    000a1 : b809; -- LOADI  9            ; loop 8 times (256 = 2^8)
    000a2 : 10b7; -- STORE  AtanT
    000a3 : 08b7; -- LOAD   AtanT
    000a4 : 6fff; -- ADDI   -1
    000a5 : 38a8; -- JPOS   A2_DN        ; not done; continue shifting
    000a6 : 80e3; -- CALL   Div16s       ; do the standard division
    000a7 : 8800; -- RETURN
    000a8 : 10b7; -- STORE  AtanT
    000a9 : 0914; -- LOAD   d16sN        ; start by trying to scale the numerator
    000aa : 6001; -- SHIFT  1
    000ab : 5914; -- XOR    d16sN        ; if the sign changed,
    000ac : 30b0; -- JNEG   A2_DD        ; switch to scaling the denominator
    000ad : 5914; -- XOR    d16sN        ; get back shifted version
    000ae : 1114; -- STORE  d16sN
    000af : 28a3; -- JUMP   A2_DL
    000b0 : 0915; -- LOAD   d16sD
    000b1 : 6011; -- SHIFT  -1           ; have to scale denominator
    000b2 : 1115; -- STORE  d16sD
    000b3 : 28a3; -- JUMP   A2_DL
    000b4 : 0000; -- AtanX:      DW 0
    000b5 : 0000; -- AtanY:      DW 0
    000b6 : 0000; -- AtanRatio:  DW 0        ; =y/x
    000b7 : 0000; -- AtanT:      DW 0        ; temporary value
    000b8 : 0048; -- A2c:        DW 72       ; 72/256=0.28125, with 8 fractional bits
    000b9 : 394c; -- A2cd:       DW 14668    ; = 180/pi with 8 fractional bits
    000ba : b800; -- LOADI  0
    000bb : 10df; -- STORE  m16sc        ; clear carry
    000bc : 10e2; -- STORE  mres16sH     ; clear result
    000bd : b810; -- LOADI  16           ; load 16 to counter
    000be : 10e0; -- STORE  mcnt16s
    000bf : 08df; -- LOAD   m16sc        ; check the carry (from previous iteration)
    000c0 : 40c4; -- JZERO  Mult16s_noc  ; if no carry, move on
    000c1 : 08e2; -- LOAD   mres16sH     ; if a carry,
    000c2 : 18dd; -- ADD    m16sA        ;  add multiplicand to result H
    000c3 : 10e2; -- STORE  mres16sH
    000c4 : 08de; -- LOAD   m16sB
    000c5 : 4950; -- AND    One          ; check bit 0 of multiplier
    000c6 : 10df; -- STORE  m16sc        ; save as next carry
    000c7 : 40cb; -- JZERO  Mult16s_sh   ; if no carry, move on to shift
    000c8 : 08e2; -- LOAD   mres16sH     ; if bit 0 set,
    000c9 : 20dd; -- SUB    m16sA        ;  subtract multiplicand from result H
    000ca : 10e2; -- STORE  mres16sH
    000cb : 08de; -- LOAD   m16sB
    000cc : 6011; -- SHIFT  -1           ; shift result L >>1
    000cd : 48dc; -- AND    c7FFF        ; clear msb
    000ce : 10de; -- STORE  m16sB
    000cf : 08e2; -- LOAD   mres16sH     ; load result H
    000d0 : 600f; -- SHIFT  15           ; move lsb to msb
    000d1 : 50de; -- OR     m16sB
    000d2 : 10de; -- STORE  m16sB        ; result L now includes carry out from H
    000d3 : 08e2; -- LOAD   mres16sH
    000d4 : 6011; -- SHIFT  -1
    000d5 : 10e2; -- STORE  mres16sH     ; shift result H >>1
    000d6 : 08e0; -- LOAD   mcnt16s
    000d7 : 6fff; -- ADDI   -1           ; check counter
    000d8 : 38be; -- JPOS   Mult16s_loop ; need to iterate 16 times
    000d9 : 08de; -- LOAD   m16sB
    000da : 10e1; -- STORE  mres16sL     ; multiplier and result L shared a word
    000db : 8800; -- RETURN              ; Done
    000dc : 7fff; -- c7FFF: DW &H7FFF
    000dd : 0000; -- m16sA: DW 0 ; multiplicand
    000de : 0000; -- m16sB: DW 0 ; multipler
    000df : 0000; -- m16sc: DW 0 ; carry
    000e0 : 0000; -- mcnt16s: DW 0 ; counter
    000e1 : 0000; -- mres16sL: DW 0 ; result low
    000e2 : 0000; -- mres16sH: DW 0 ; result high
    000e3 : b800; -- LOADI  0
    000e4 : 111b; -- STORE  dres16sR     ; clear remainder result
    000e5 : 1118; -- STORE  d16sC1       ; clear carry
    000e6 : 0914; -- LOAD   d16sN
    000e7 : 5915; -- XOR    d16sD
    000e8 : 1116; -- STORE  d16sS        ; sign determination = N XOR D
    000e9 : b811; -- LOADI  17
    000ea : 1117; -- STORE  d16sT        ; preload counter with 17 (16+1)
    000eb : 0915; -- LOAD   d16sD
    000ec : 8051; -- CALL   Abs          ; take absolute value of denominator
    000ed : 1115; -- STORE  d16sD
    000ee : 0914; -- LOAD   d16sN
    000ef : 8051; -- CALL   Abs          ; take absolute value of numerator
    000f0 : 1114; -- STORE  d16sN
    000f1 : 0914; -- LOAD   d16sN
    000f2 : 601f; -- SHIFT  -15          ; get msb
    000f3 : 4950; -- AND    One          ; only msb (because shift is arithmetic)
    000f4 : 1119; -- STORE  d16sC2       ; store as carry
    000f5 : 0914; -- LOAD   d16sN
    000f6 : 6001; -- SHIFT  1            ; shift <<1
    000f7 : 5118; -- OR     d16sC1       ; with carry
    000f8 : 1114; -- STORE  d16sN
    000f9 : 0917; -- LOAD   d16sT
    000fa : 6fff; -- ADDI   -1           ; decrement counter
    000fb : 410b; -- JZERO  Div16s_sign  ; if finished looping, finalize result
    000fc : 1117; -- STORE  d16sT
    000fd : 091b; -- LOAD   dres16sR
    000fe : 6001; -- SHIFT  1            ; shift remainder
    000ff : 5119; -- OR     d16sC2       ; with carry from other shift
    00100 : 2115; -- SUB    d16sD        ; subtract denominator from remainder
    00101 : 3106; -- JNEG   Div16s_add   ; if negative, need to add it back
    00102 : 111b; -- STORE  dres16sR
    00103 : b801; -- LOADI  1
    00104 : 1118; -- STORE  d16sC1       ; set carry
    00105 : 28f1; -- JUMP   Div16s_loop
    00106 : 1915; -- ADD    d16sD        ; add denominator back in
    00107 : 111b; -- STORE  dres16sR
    00108 : b800; -- LOADI  0
    00109 : 1118; -- STORE  d16sC1       ; clear carry
    0010a : 28f1; -- JUMP   Div16s_loop
    0010b : 0914; -- LOAD   d16sN
    0010c : 111a; -- STORE  dres16sQ     ; numerator was used to hold quotient result
    0010d : 0916; -- LOAD   d16sS        ; check the sign indicator
    0010e : 3110; -- JNEG   Div16s_neg
    0010f : 8800; -- RETURN
    00110 : 091a; -- LOAD   dres16sQ     ; need to negate the result
    00111 : 8052; -- CALL   Neg
    00112 : 111a; -- STORE  dres16sQ
    00113 : 8800; -- RETURN
    00114 : 0000; -- d16sN: DW 0 ; numerator
    00115 : 0000; -- d16sD: DW 0 ; denominator
    00116 : 0000; -- d16sS: DW 0 ; sign value
    00117 : 0000; -- d16sT: DW 0 ; temp counter
    00118 : 0000; -- d16sC1: DW 0 ; carry value
    00119 : 0000; -- d16sC2: DW 0 ; carry value
    0011a : 0000; -- dres16sQ: DW 0 ; quotient result
    0011b : 0000; -- dres16sR: DW 0 ; remainder result
    0011c : 0946; -- LOAD   L2A
    0011d : 8051; -- CALL   Abs
    0011e : 1148; -- STORE  L2T1
    0011f : 0947; -- LOAD   L2B
    00120 : 8051; -- CALL   Abs
    00121 : 2148; -- SUB    L2T1
    00122 : 313e; -- JNEG   GDSwap    ; swap if needed to get largest value in X
    00123 : 1948; -- ADD    L2T1
    00124 : 10dd; -- STORE  m16sa
    00125 : b8f6; -- LOADI  246       ; max * 246
    00126 : 10de; -- STORE  m16sB
    00127 : 80ba; -- CALL   Mult16s
    00128 : 08e2; -- LOAD   mres16sH
    00129 : 6008; -- SHIFT  8
    0012a : 1149; -- STORE  L2T2
    0012b : 08e1; -- LOAD   mres16sL
    0012c : 6018; -- SHIFT  -8        ; / 256
    0012d : 495a; -- AND    LoByte
    0012e : 5149; -- OR     L2T2
    0012f : 114a; -- STORE  L2T3
    00130 : 0948; -- LOAD   L2T1
    00131 : 10dd; -- STORE  m16sa
    00132 : b868; -- LOADI  104       ; min * 104
    00133 : 10de; -- STORE  m16sB
    00134 : 80ba; -- CALL   Mult16s
    00135 : 08e2; -- LOAD   mres16sH
    00136 : 6008; -- SHIFT  8
    00137 : 1149; -- STORE  L2T2
    00138 : 08e1; -- LOAD   mres16sL
    00139 : 6018; -- SHIFT  -8        ; / 256
    0013a : 495a; -- AND    LoByte
    0013b : 5149; -- OR     L2T2
    0013c : 194a; -- ADD    L2T3     ; sum
    0013d : 8800; -- RETURN
    0013e : 1948; -- ADD    L2T1
    0013f : 1149; -- STORE  L2T2
    00140 : 0948; -- LOAD   L2T1
    00141 : 114a; -- STORE  L2T3
    00142 : 0949; -- LOAD   L2T2
    00143 : 1148; -- STORE  L2T1
    00144 : 094a; -- LOAD   L2T3
    00145 : 2924; -- JUMP   CalcDist
    00146 : 0000; -- L2A:  DW 0
    00147 : 0000; -- L2B:  DW 0
    00148 : 0000; -- L2T1: DW 0
    00149 : 0000; -- L2T2: DW 0
    0014a : 0000; -- L2T3: DW 0
    0014b : 0000; -- Temp:      DW 0
    0014c : 0000; -- Pattern:   DW 0
    0014d : 0000; -- Score:     DW 0
    0014e : 0000; -- Zero:      DW 0
    0014f : ffff; -- NegOne:    DW -1
    00150 : 0001; -- Bit0:      DW &B0000000001
    00151 : 0002; -- Bit1:      DW &B0000000010
    00152 : 0004; -- Bit2:      DW &B0000000100
    00153 : 0008; -- Bit3:      DW &B0000001000
    00154 : 0010; -- Bit4:      DW &B0000010000
    00155 : 0020; -- Bit5:      DW &B0000100000
    00156 : 0040; -- Bit6:      DW &B0001000000
    00157 : 0080; -- Bit7:      DW &B0010000000
    00158 : 0100; -- Bit8:      DW &B0100000000
    00159 : 0200; -- Bit9:      DW &B1000000000
    0015a : 00ff; -- LoByte:    DW &H00FF
    0015b : ff00; -- HiByte:    DW &HFF00
    0015c : 203a; -- I2CWCmd:  DW &H203A    ; write two i2c bytes, addr 0x3A
    0015d : 123a; -- I2CRCmd:  DW &H123A    ; write one byte, read two bytes, addr 0x3A
    0015e : 0032; -- AccXAddr: DW &H32      ; X acceleration register address.
    0015f : 0034; -- AccYAddr: DW &H34      ; Y acceleration register address.
    00160 : 0006; -- DW 6           ; Number of commands to send
    00161 : 3100; -- DW &H3100      ; Dummy transaction to sync I2C bus if needed
    00162 : 3100; -- DW &H3100      ; Dummy transaction to sync I2C bus if needed
    00163 : 3100; -- DW &H3100      ; Right-justified 10-bit data, +/-2 G
    00164 : 3800; -- DW &H3800      ; No FIFO
    00165 : 2c0a; -- DW &H2C0A      ; 25 samples per second
    00166 : 2d08; -- DW &H2D08      ; No sleep

    [00167..007ff] : 0000; -- Empty memory
    [00800..fffff] : 0000; -- Empty memory

  END;
